{"data": {"question": {"questionId": "57", "title": "Insert Interval", "titleSlug": "insert-interval", "content": "<p>You are given an array of non-overlapping intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code> represent the start and the end of the <code>i<sup>th</sup></code> interval and <code>intervals</code> is sorted in ascending order by <code>start<sub>i</sub></code>. You are also given an interval <code>newInterval = [start, end]</code> that represents the start and end of another interval.</p>\n\n<p>Insert <code>newInterval</code> into <code>intervals</code> such that <code>intervals</code> is still sorted in ascending order by <code>start<sub>i</sub></code> and <code>intervals</code> still does not have any overlapping intervals (merge overlapping intervals if necessary).</p>\n\n<p>Return <code>intervals</code><em> after the insertion</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]\n<strong>Output:</strong> [[1,5],[6,9]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\n<strong>Output:</strong> [[1,2],[3,10],[12,16]]\n<strong>Explanation:</strong> Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= intervals.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals</code> is sorted by <code>start<sub>i</sub></code> in <strong>ascending</strong> order.</li>\n\t<li><code>newInterval.length == 2</code></li>\n\t<li><code>0 &lt;= start &lt;= end &lt;= 10<sup>5</sup></code></li>\n</ul>\n", "difficulty": "Medium", "isPaidOnly": false, "hints": [], "likes": 8297, "dislikes": 577, "companyTagStats": null, "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        "}, {"lang": "C", "langSlug": "c", "code": "/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** insert(int** intervals, int intervalsSize, int* intervalsColSize, int* newInterval, int newIntervalSize, int* returnSize, int** returnColumnSizes){\n\n}"}, {"lang": "C#", "langSlug": "csharp", "code": "public class Solution {\n    public int[][] Insert(int[][] intervals, int[] newInterval) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nvar insert = function(intervals, newInterval) {\n    \n};"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# @param {Integer[][]} intervals\n# @param {Integer[]} new_interval\n# @return {Integer[][]}\ndef insert(intervals, new_interval)\n    \nend"}, {"lang": "Swift", "langSlug": "swift", "code": "class Solution {\n    func insert(_ intervals: [[Int]], _ newInterval: [Int]) -> [[Int]] {\n        \n    }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "func insert(intervals [][]int, newInterval []int) [][]int {\n    \n}"}, {"lang": "Scala", "langSlug": "scala", "code": "object Solution {\n    def insert(intervals: Array[Array[Int]], newInterval: Array[Int]): Array[Array[Int]] = {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "class Solution {\n    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "impl Solution {\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n        \n    }\n}"}, {"lang": "PHP", "langSlug": "php", "code": "class Solution {\n\n    /**\n     * @param Integer[][] $intervals\n     * @param Integer[] $newInterval\n     * @return Integer[][]\n     */\n    function insert($intervals, $newInterval) {\n        \n    }\n}"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "function insert(intervals: number[][], newInterval: number[]): number[][] {\n\n};"}, {"lang": "Racket", "langSlug": "racket", "code": "(define/contract (insert intervals newInterval)\n  (-> (listof (listof exact-integer?)) (listof exact-integer?) (listof (listof exact-integer?)))\n\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "-spec insert(Intervals :: [[integer()]], NewInterval :: [integer()]) -> [[integer()]].\ninsert(Intervals, NewInterval) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "defmodule Solution do\n  @spec insert(intervals :: [[integer]], new_interval :: [integer]) :: [[integer]]\n  def insert(intervals, new_interval) do\n\n  end\nend"}, {"lang": "Dart", "langSlug": "dart", "code": "class Solution {\n  List<List<int>> insert(List<List<int>> intervals, List<int> newInterval) {\n\n  }\n}"}], "metaData": "{\r\n  \"name\": \"insert\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"intervals\",\r\n      \"type\": \"integer[][]\"\r\n    },\r\n    {\r\n      \"name\": \"newInterval\",\r\n      \"type\": \"integer[]\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer[][]\"\r\n  }\r\n}", "topicTags": [{"name": "Array", "slug": "array"}], "similarQuestionList": [{"difficulty": "Medium", "titleSlug": "merge-intervals", "title": "Merge Intervals", "translatedTitle": null, "isPaidOnly": false}, {"difficulty": "Hard", "titleSlug": "range-module", "title": "Range Module", "translatedTitle": null, "isPaidOnly": false}, {"difficulty": "Hard", "titleSlug": "count-integers-in-intervals", "title": "Count Integers in Intervals", "translatedTitle": null, "isPaidOnly": false}], "mysqlSchemas": [], "stats": "{\"totalAccepted\": \"763.9K\", \"totalSubmission\": \"2M\", \"totalAcceptedRaw\": 763912, \"totalSubmissionRaw\": 1952968, \"acRate\": \"39.1%\"}", "solution": {"id": "1644", "title": "Insert Intervals", "content": "[TOC]\n\n## Solution\n\n--- \n\n#### Overview\n\nWe have $N$ non-overlapping intervals in ascending order of their `start` value; given one more interval `newInterval` we want to insert this interval in the list keeping the order intact and merging the possible overlapping intervals.\n\nThe solution to this problem will be straightforward to understand if we can find the solution to the below three sub-problems.\n\n<details><summary>1. How can we tell if two given intervals overlaps?</summary>\n\n> If we have two intervals say $(a_1, b_1)$ and $(a_2, b_2)$, they overlap if the number of common elements between them is non-zero. The possible common range between these two ranges can be represented as $(max(a_1, a_2), min(b_1, b_2))$; this is because the common range will start from the maximum of the two starting points and will end at the minimum of the two ending points. We have the range, but this might be empty if the range is $(x, y)$ and $x > y$. Hence, the final criteria for the given range to be overlapping would be $(min(b_1, b_2) - max(a_1, a_2)) >= 0$, note that the condition also includes $0$ as that would mean a single element overlap.\n\n</details>\n\n<details><summary>2. How to merge two overlapping intervals?</summary>\n\n> If we have two intervals say $(a_1, b_1)$ and $(a_2, b_2)$, and they overlap. The single interval covering elements in both intervals would start from the minimum of starting points of the two ranges and will end at the maximum of the two ending points in the ranges. Hence the merged interval would be $(min(a_1, a_2) , max(b_1, b_2))$.\n\n</details>\n\n<details><summary>3. Given a list of N intervals in ascending order of their `start` values, how can we merge possible overlapping intervals in the list, keeping the ascending order intact?</summary>\n\n> If we have, say $N$ such intervals, then we can iterate over each interval and try to merge them with the subsequent intervals in the list. Let's say we have the interval `(x, y)`, then we will iterate over the next interval using a while loop and check if these two intervals overlap (using the answer to question #1), and if they overlap, we will merge them (using the answer in question #2) and move on to the next interval. This will continue until we run out of the intervals in the list or the intervals don't overlap; in either case, we will store the updated interval in the final answer list. Note that we have to decrement the counter variable after we get out of the while loop; otherwise, we will skip the next interval because of incrementing the counter variable again in the outer for-loop.\n\n**Code**\n<iframe src=\"https://leetcode.com/playground/bDGdnVx5/shared\" frameBorder=\"0\" width=\"100%\" height=\"259\" name=\"bDGdnVx5\"></iframe>\n\n</details>\n</br>\n\n---\n\n#### Approach 1: Linear Search\n\n**Intuition**\n\nSince we now understand the answer to the above three sub-problems, let's start with the original problem. How can we convert the original problem into the #3 sub-problem we just discussed above? For this, we will need to insert the `newInterval` into the original list keeping the start value of intervals in ascending order. So, the new problem is given $N$ intervals in ascending order of the start and another interval, `newInterval`, insert the `newInterval` in the list in the order of its start value.\n\nThis can be done using linear search, we can iterate over the intervals in the list, and the `newInterval` should be inserted just before the interval having a greater `start` value. This way, we can produce the list of intervals in ascending order of their `start` value and solve it using the algorithm discussed in question #3 above.\n\n!?!../Documents/57_Insert_Intervals.json:960,720!?!\n\n**Algorithm**\n\n1. Insert the `newInterval` into the given list of `intervals` using linear search. Iterate over the list and find the first interval with a start value greater than the `newInterval`. Insert `newInterval` just before this interval or at the end of the list if no such interval exists.\n2. Iterate over the intervals in the list `intervals`; for each interval `currInterval`\n\n    - Iterate over the intervals ahead of it in the list (including itself), and if the two interval overlaps, update `currInterval` to the merged interval of these two intervals and move on to the next interval.\n3. Decrement the loop counter variable, as it will be incremented again in the outer loop, and if we don't decrement it here, the next interval will be missed.\n4. Insert the interval `currInterval` in the list `answer`.\n5. Return `answer`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/Q3f8PtmU/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"Q3f8PtmU\"></iframe>\n\n**Complexity Analysis**\n\nHere $N$ is the number of intervals in the list.\n\n* Time complexity: $O(N)$.\n\n  Inserting the interval initially will take $O(N)$ time as we might end up iterating over the complete list; also, inserting into the list at the mentioned position will take $O(N)$ time. Then iterating over the intervals and merging them with intervals ahead of it will take another $O(N)$ time. Hence, the total time complexity will equal $O(N)$.\n\n* Space complexity: $O(1)$.\n\n  Inserting an interval into the list will take $O(1)$ space. Therefore, apart from the list we return, the total space complexity would be constant.\n  <br/>\n\n---\n\n#### Approach 2: Binary Search\n\n**Intuition**\n\nThe only difference with this approach would be that instead of using linear search to find the suitable position of `newInterval`, we can use binary search as the list of intervals is sorted in order of their start time.\n\nWe need to find the first interval in the list `intervals` having a start value greater than the start value of `newInterval`. In languages like `C++`, we can use STL functions like `upper_bound` to get the position, or we can implement our own basic binary search algorithm.\n\nApart from this change, the logic remains the same for this approach; we insert the interval at its place using binary search and then merge the overlapping intervals using the same algorithm we used previously.\n\n**Algorithm**\n\n1. Insert the `newInterval` into the given list `intervals` using binary search. Find the index using binary search and if it's equal to the size of the list, then add the interval to the end of the list; otherwise, insert it at the respective position.\n\n2. Iterate over the intervals in the list `intervals`; for each interval `currInterval`\n\n    - Iterate over the intervals ahead of it in the list (including itself), and if the two interval overlaps, update `currInterval` to the merged interval of these two intervals and move on to the next interval.\n3. Decrement the loop counter variable, as it will be incremented again in the outer loop, and if we don't decrement it here, the next interval will be missed.\n4. Insert the interval `currInterval` in the list `answer`.\n5. Return `answer`.\n\n**Implementation**\n\n<iframe src=\"https://leetcode.com/playground/TWhQTupC/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\" name=\"TWhQTupC\"></iframe>\n\n**Complexity Analysis**\n\nHere $N$ is the number of intervals in the list.\n\n* Time complexity: $O(N)$.\n\n  Binary search will take $O(\\log N)$ time, but inserting into the list at the returned position will take $O(N)$ time. Then iterating over the intervals and merging them with intervals ahead of it will take another $O(N)$ time. Hence, the total time complexity will equal $O(N)$.\n\n* Space complexity: $O(1)$.\n\n  Inserting an interval into the list will take $O(1)$ space. Therefore, apart from the list we return, the total space complexity would be constant.\n  <br/>\n\n---", "contentTypeId": "107", "paidOnly": false, "hasVideoSolution": false, "paidOnlyVideo": true, "canSeeDetail": true, "rating": {"count": 53, "average": "3.755", "userRating": null}, "topic": {"id": 2914120, "commentCount": 42, "topLevelCommentCount": 27, "favoriteCount": 0, "viewCount": 117651, "subscribed": false, "solutionTags": [], "post": {"id": 4634512, "status": null, "creationDate": 1671098768, "author": {"username": "LeetCode", "isActive": true, "profile": {"userAvatar": "https://assets.leetcode.com/users/leetcode/avatar_1568224780.png", "reputation": 27343}}}}}}}}