{"data": {"question": {"questionId": "230", "title": "Kth Smallest Element in a BST", "titleSlug": "kth-smallest-element-in-a-bst", "content": "<p>Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\" style=\"width: 212px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [3,1,4,null,2], k = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\" style=\"width: 382px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [5,3,6,2,4,null,null,1], k = 3\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is <code>n</code>.</li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?</p>\n", "difficulty": "Medium", "isPaidOnly": false, "hints": ["Try to utilize the property of a BST.", "Try in-order traversal. (Credits to @chan13)", "What if you could modify the BST node's structure?", "The optimal runtime complexity is O(height of BST)."], "likes": 9718, "dislikes": 175, "companyTagStats": null, "codeSnippets": [{"lang": "C++", "langSlug": "cpp", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        \n    }\n};"}, {"lang": "Java", "langSlug": "java", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        \n    }\n}"}, {"lang": "Python", "langSlug": "python", "code": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def kthSmallest(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        "}, {"lang": "Python3", "langSlug": "python3", "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        "}, {"lang": "C", "langSlug": "c", "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\nint kthSmallest(struct TreeNode* root, int k){\n\n}"}, {"lang": "C#", "langSlug": "csharp", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n    public int KthSmallest(TreeNode root, int k) {\n        \n    }\n}"}, {"lang": "JavaScript", "langSlug": "javascript", "code": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} k\n * @return {number}\n */\nvar kthSmallest = function(root, k) {\n    \n};"}, {"lang": "Ruby", "langSlug": "ruby", "code": "# Definition for a binary tree node.\n# class TreeNode\n#     attr_accessor :val, :left, :right\n#     def initialize(val = 0, left = nil, right = nil)\n#         @val = val\n#         @left = left\n#         @right = right\n#     end\n# end\n# @param {TreeNode} root\n# @param {Integer} k\n# @return {Integer}\ndef kth_smallest(root, k)\n    \nend"}, {"lang": "Swift", "langSlug": "swift", "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public var val: Int\n *     public var left: TreeNode?\n *     public var right: TreeNode?\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\n *         self.val = val\n *         self.left = left\n *         self.right = right\n *     }\n * }\n */\nclass Solution {\n    func kthSmallest(_ root: TreeNode?, _ k: Int) -> Int {\n        \n    }\n}"}, {"lang": "Go", "langSlug": "golang", "code": "/**\n * Definition for a binary tree node.\n * type TreeNode struct {\n *     Val int\n *     Left *TreeNode\n *     Right *TreeNode\n * }\n */\nfunc kthSmallest(root *TreeNode, k int) int {\n    \n}"}, {"lang": "Scala", "langSlug": "scala", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\n *   var value: Int = _value\n *   var left: TreeNode = _left\n *   var right: TreeNode = _right\n * }\n */\nobject Solution {\n    def kthSmallest(root: TreeNode, k: Int): Int = {\n        \n    }\n}"}, {"lang": "Kotlin", "langSlug": "kotlin", "code": "/**\n * Example:\n * var ti = TreeNode(5)\n * var v = ti.`val`\n * Definition for a binary tree node.\n * class TreeNode(var `val`: Int) {\n *     var left: TreeNode? = null\n *     var right: TreeNode? = null\n * }\n */\nclass Solution {\n    fun kthSmallest(root: TreeNode?, k: Int): Int {\n        \n    }\n}"}, {"lang": "Rust", "langSlug": "rust", "code": "// Definition for a binary tree node.\n// #[derive(Debug, PartialEq, Eq)]\n// pub struct TreeNode {\n//   pub val: i32,\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\n// }\n// \n// impl TreeNode {\n//   #[inline]\n//   pub fn new(val: i32) -> Self {\n//     TreeNode {\n//       val,\n//       left: None,\n//       right: None\n//     }\n//   }\n// }\nuse std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn kth_smallest(root: Option<Rc<RefCell<TreeNode>>>, k: i32) -> i32 {\n        \n    }\n}"}, {"lang": "PHP", "langSlug": "php", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     public $val = null;\n *     public $left = null;\n *     public $right = null;\n *     function __construct($val = 0, $left = null, $right = null) {\n *         $this->val = $val;\n *         $this->left = $left;\n *         $this->right = $right;\n *     }\n * }\n */\nclass Solution {\n\n    /**\n     * @param TreeNode $root\n     * @param Integer $k\n     * @return Integer\n     */\n    function kthSmallest($root, $k) {\n        \n    }\n}"}, {"lang": "TypeScript", "langSlug": "typescript", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction kthSmallest(root: TreeNode | null, k: number): number {\n\n};"}, {"lang": "Racket", "langSlug": "racket", "code": "; Definition for a binary tree node.\n#|\n\n; val : integer?\n; left : (or/c tree-node? #f)\n; right : (or/c tree-node? #f)\n(struct tree-node\n  (val left right) #:mutable #:transparent)\n\n; constructor\n(define (make-tree-node [val 0])\n  (tree-node val #f #f))\n\n|#\n\n(define/contract (kth-smallest root k)\n  (-> (or/c tree-node? #f) exact-integer? exact-integer?)\n\n  )"}, {"lang": "Erlang", "langSlug": "erlang", "code": "%% Definition for a binary tree node.\n%%\n%% -record(tree_node, {val = 0 :: integer(),\n%%                     left = null  :: 'null' | #tree_node{},\n%%                     right = null :: 'null' | #tree_node{}}).\n\n-spec kth_smallest(Root :: #tree_node{} | null, K :: integer()) -> integer().\nkth_smallest(Root, K) ->\n  ."}, {"lang": "Elixir", "langSlug": "elixir", "code": "# Definition for a binary tree node.\n#\n# defmodule TreeNode do\n#   @type t :: %__MODULE__{\n#           val: integer,\n#           left: TreeNode.t() | nil,\n#           right: TreeNode.t() | nil\n#         }\n#   defstruct val: 0, left: nil, right: nil\n# end\n\ndefmodule Solution do\n  @spec kth_smallest(root :: TreeNode.t | nil, k :: integer) :: integer\n  def kth_smallest(root, k) do\n\n  end\nend"}, {"lang": "Dart", "langSlug": "dart", "code": "/**\n * Definition for a binary tree node.\n * class TreeNode {\n *   int val;\n *   TreeNode? left;\n *   TreeNode? right;\n *   TreeNode([this.val = 0, this.left, this.right]);\n * }\n */\nclass Solution {\n  int kthSmallest(TreeNode? root, int k) {\n\n  }\n}"}], "metaData": "{\r\n  \"name\": \"kthSmallest\",\r\n  \"params\": [\r\n    {\r\n      \"name\": \"root\",\r\n      \"type\": \"TreeNode\"\r\n    },\r\n    {\r\n      \"name\": \"k\",\r\n      \"type\": \"integer\"\r\n    }\r\n  ],\r\n  \"return\": {\r\n    \"type\": \"integer\"\r\n  }\r\n}", "topicTags": [{"name": "Tree", "slug": "tree"}, {"name": "Depth-First Search", "slug": "depth-first-search"}, {"name": "Binary Search Tree", "slug": "binary-search-tree"}, {"name": "Binary Tree", "slug": "binary-tree"}], "similarQuestionList": [{"difficulty": "Easy", "titleSlug": "binary-tree-inorder-traversal", "title": "Binary Tree Inorder Traversal", "translatedTitle": null, "isPaidOnly": false}, {"difficulty": "Easy", "titleSlug": "second-minimum-node-in-a-binary-tree", "title": "Second Minimum Node In a Binary Tree", "translatedTitle": null, "isPaidOnly": false}], "mysqlSchemas": [], "stats": "{\"totalAccepted\": \"1.1M\", \"totalSubmission\": \"1.5M\", \"totalAcceptedRaw\": 1087700, \"totalSubmissionRaw\": 1545771, \"acRate\": \"70.4%\"}", "solution": {"id": "723", "title": "Kth Smallest Element in a BST", "content": "[TOC]\n\n## Solution\n\n--- \n\n#### How to traverse the tree\n\nThere are two general strategies to traverse a tree:\n     \n- *Depth First Search* (`DFS`)\n\n    In this strategy, we adopt the `depth` as the priority, so that one\n    would start from a root and reach all the way down to certain leaf,\n    and then back to root to reach another branch.\n\n    The DFS strategy can further be distinguished as\n    `preorder`, `inorder`, and `postorder` depending on the relative order\n    among the root node, left node and right node.\n    \n- *Breadth First Search* (`BFS`)\n\n    We scan through the tree level by level, following the order of height,\n    from top to bottom. The nodes on higher level would be visited before\n    the ones with lower levels.\n    \nOn the following figure the nodes are numerated in the order you visit them,\nplease follow `1-2-3-4-5` to compare different strategies.\n\n![postorder](../Figures/230/bfs_dfs.png)\n\n> To solve the problem, one could use the property of BST : inorder traversal of BST\nis an array sorted in the ascending order. \n\n<br /> \n<br />\n\n\n---\n#### Approach 1: Recursive Inorder Traversal\n\nIt's a very straightforward approach with $$O(N)$$ \ntime complexity.\nThe idea is to build an inorder traversal of BST which is \nan array sorted in the ascending order. \nNow the answer is the `k - 1`th element of this array. \n\n![bla](../Figures/230/inorder.png)\n\n<iframe src=\"https://leetcode.com/playground/2ZkcqDoS/shared\" frameBorder=\"0\" width=\"100%\" height=\"293\" name=\"2ZkcqDoS\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity : $$O(N)$$ to build a traversal. \n* Space complexity : $$O(N)$$ to keep an inorder traversal.\n<br />\n<br />\n\n\n---\n#### Approach 2: Iterative Inorder Traversal\n\nThe above recursion could be converted into iteration, \nwith the help of stack. This way one could speed up the solution \nbecause there is no need to build the entire inorder traversal,\nand one could stop after the kth element.\n\n![bla](../Figures/230/iteration.png)\n\n<iframe src=\"https://leetcode.com/playground/26KSgh2H/shared\" frameBorder=\"0\" width=\"100%\" height=\"361\" name=\"26KSgh2H\"></iframe>\n\n**Complexity Analysis**\n\n* Time complexity: $$O(H + k)$$, where $$H$$ is a tree height.\nThis complexity is defined by the stack, which contains at least $$H + k$$ elements, since before\nstarting to pop out one has to go down to a leaf. This results in \n$$O(\\log N + k)$$ for the balanced tree and \n$$O(N + k)$$ for completely unbalanced tree with all\n the nodes in the left subtree. \n* Space complexity: $$O(H)$$ to keep the stack, \nwhere $$H$$ is a tree height. That makes \n$$O(N)$$ in the worst case of the skewed tree,\nand $$O(\\log N)$$ in the average case of the balanced tree.\n<br />\n<br />\n\n\n---\n#### Follow up\n\n> What if the BST is modified (insert/delete operations) \noften and you need to find the kth smallest frequently? \nHow would you optimize the kthSmallest routine?\n\nClick here to learn how to [insert a node into a BST](https://leetcode.com/articles/insert-into-a-bst/) \nand [delete a node from a BST](https://leetcode.com/articles/delete-node-in-a-bst/), \nthe time complexity of these \noperations is $$O(H)$$, where $$H$$ is a height of the binary tree.\n$$H = \\log N$$ for the balanced tree and $$H = N$$ for a skewed tree.\n\nHence without any optimisation insert/delete + search of kth element has \n$$O(2H + k)$$ complexity. \nHow to optimise that? \n\nThat's a design question, \nbasically we're asked to implement a structure \nwhich contains a BST inside and\noptimises the following operations :\n\n- Insert\n\n- Delete\n\n- Find kth smallest\n\nSeems like a database description, isn't it? \nLet's use here the same logic as for [LRU cache](https://leetcode.com/articles/lru-cache/)\ndesign, and combine an indexing structure (we could keep BST here)\nwith a double linked list. \n\nSuch a structure would provide:\n\n- $$O(H)$$ time for the insert and delete.\n\n- $$O(k)$$ for the search of kth smallest.\n\n![bla](../Figures/230/linked_list2.png)\n\nThe overall time complexity for insert/delete + search of kth smallest\nis $$O(H + k)$$ instead of $$O(2H + k)$$. \n\n**Complexity Analysis**\n\n* Time complexity for insert/delete + search of kth smallest: \n$$O(H + k)$$, where $$H$$ is a tree height.\n$$O(\\log N + k)$$ in the average case,\n$$O(N + k)$$ in the worst case.\n\n* Space complexity : $$O(N)$$ to keep the linked list.", "contentTypeId": "107", "paidOnly": false, "hasVideoSolution": false, "paidOnlyVideo": true, "canSeeDetail": true, "rating": {"count": 273, "average": "4.502", "userRating": null}, "topic": {"id": 284145, "commentCount": 293, "topLevelCommentCount": 190, "favoriteCount": 0, "viewCount": 423625, "subscribed": false, "solutionTags": [], "post": {"id": 553578, "status": null, "creationDate": 1556611087, "author": {"username": "LeetCode", "isActive": true, "profile": {"userAvatar": "https://assets.leetcode.com/users/leetcode/avatar_1568224780.png", "reputation": 27343}}}}}}}}